{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"[ ] 15 [ ] 13 [ ] 13 [ ] 18 Dark magics about variable names in python Change Log | API Installation pip install varname Features Fetching variable names from inside the function/class call using varname Fetching variable names directly using nameof A value wrapper to store the variable name that a value is assigned to using Wrapper Detecting next immediate attribute name using will Injecting __varname__ to objects A debug function to print variables with their names and values. Credits Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project. Usage Retrieving the variable names from inside a function call/class instantiation From insdie a function call from varname import varname def function (): return varname () func = function () # func == 'func' varname calls being buried deeply def function (): # I know that at which stack this will be called return varname ( caller = 3 ) def function1 (): return function () def function2 (): return function1 () func = function2 () # func == 'func' Retrieving instance name of a class class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied k = Foo () # k.id == 'k' k2 = k . copy () # k2.id == 'k2' Some unusual use func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be printed # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None Value wrapper from varname import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False} Getting variable names directly from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b' Detecting next immediate attribute name from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!' Injecting __varname__ from varname import inject class MyList ( list ): pass a = inject ( MyList ()) b = inject ( MyList ()) a . __varname__ == 'a' b . __varname__ == 'b' a == b # other methods not affected a . append ( 1 ) b . append ( 1 ) a == b Debugging with debug a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value Reliability and limitations varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Home"},{"location":"#installation","text":"pip install varname","title":"Installation"},{"location":"#features","text":"Fetching variable names from inside the function/class call using varname Fetching variable names directly using nameof A value wrapper to store the variable name that a value is assigned to using Wrapper Detecting next immediate attribute name using will Injecting __varname__ to objects A debug function to print variables with their names and values.","title":"Features"},{"location":"#credits","text":"Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project.","title":"Credits"},{"location":"#usage","text":"","title":"Usage"},{"location":"#retrieving-the-variable-names-from-inside-a-function-callclass-instantiation","text":"From insdie a function call from varname import varname def function (): return varname () func = function () # func == 'func' varname calls being buried deeply def function (): # I know that at which stack this will be called return varname ( caller = 3 ) def function1 (): return function () def function2 (): return function1 () func = function2 () # func == 'func' Retrieving instance name of a class class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied k = Foo () # k.id == 'k' k2 = k . copy () # k2.id == 'k2' Some unusual use func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be printed # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None","title":"Retrieving the variable names from inside a function call/class instantiation"},{"location":"#value-wrapper","text":"from varname import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False}","title":"Value wrapper"},{"location":"#getting-variable-names-directly","text":"from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b'","title":"Getting variable names directly"},{"location":"#detecting-next-immediate-attribute-name","text":"from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!'","title":"Detecting next immediate attribute name"},{"location":"#injecting-__varname__","text":"from varname import inject class MyList ( list ): pass a = inject ( MyList ()) b = inject ( MyList ()) a . __varname__ == 'a' b . __varname__ == 'b' a == b # other methods not affected a . append ( 1 ) b . append ( 1 ) a == b","title":"Injecting __varname__"},{"location":"#debugging-with-debug","text":"a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value","title":"Debugging with debug"},{"location":"#reliability-and-limitations","text":"varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Reliability and limitations"},{"location":"CHANGELOG/","text":"v0.5.3 Add debug function Deprecate namedtuple (will be removed in 0.6.0 ) v0.5.2 Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked. v0.5.1 Add better messaging for weird nameof calls v0.5.0 Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available. v0.4.0 Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning . v0.3.0 Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14) v0.2.0 Fix #5 and fit nameof in more cases v0.1.7 Add inject function v0.1.6 Fit situations when frames cannot be fetched Add shortcut for namedtuple v0.1.5 Fix will from a property call v0.1.4 Add will to detect next immediate attribute name v0.1.3 Add arugment raise_exc for varname to raise an exception instead of returning var_<index> v0.1.2 Add function nameof v0.1.1 Add a value wrapper Wrapper class v0.1.0 Implement varname function","title":"Change Log"},{"location":"CHANGELOG/#v053","text":"Add debug function Deprecate namedtuple (will be removed in 0.6.0 )","title":"v0.5.3"},{"location":"CHANGELOG/#v052","text":"Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked.","title":"v0.5.2"},{"location":"CHANGELOG/#v051","text":"Add better messaging for weird nameof calls","title":"v0.5.1"},{"location":"CHANGELOG/#v050","text":"Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available.","title":"v0.5.0"},{"location":"CHANGELOG/#v040","text":"Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning .","title":"v0.4.0"},{"location":"CHANGELOG/#v030","text":"Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14)","title":"v0.3.0"},{"location":"CHANGELOG/#v020","text":"Fix #5 and fit nameof in more cases","title":"v0.2.0"},{"location":"CHANGELOG/#v017","text":"Add inject function","title":"v0.1.7"},{"location":"CHANGELOG/#v016","text":"Fit situations when frames cannot be fetched Add shortcut for namedtuple","title":"v0.1.6"},{"location":"CHANGELOG/#v015","text":"Fix will from a property call","title":"v0.1.5"},{"location":"CHANGELOG/#v014","text":"Add will to detect next immediate attribute name","title":"v0.1.4"},{"location":"CHANGELOG/#v013","text":"Add arugment raise_exc for varname to raise an exception instead of returning var_<index>","title":"v0.1.3"},{"location":"CHANGELOG/#v012","text":"Add function nameof","title":"v0.1.2"},{"location":"CHANGELOG/#v011","text":"Add a value wrapper Wrapper class","title":"v0.1.1"},{"location":"CHANGELOG/#v010","text":"Implement varname function","title":"v0.1.0"},{"location":"api/varname/","text":"module varname </> Dark magics about variable name in python Classes VarnameRetrievingError \u2014 When failed to retrieve the varname </> Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> inject ( obj ) (object) \u2014 Inject attribute __varname__ to an object </> namedtuple ( *args , **kwargs ) (type) \u2014 A shortcut for namedtuple </> nameof ( var , *more_vars , caller , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( caller , raise_exc ) (str, optional) \u2014 Get the variable name that assigned by function/class calls </> will ( caller , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> class varname . VarnameRetrievingError ( ) </> Bases Exception BaseException When failed to retrieve the varname function varname . varname ( caller=1 , raise_exc=True ) </> Get the variable name that assigned by function/class calls Parameters caller (int, optional) \u2014 The call stack index, indicating where this function is called relative to where the variable is finally retrieved raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (str, optional) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variable used on the left of the assign node. (e.g: a.b = func() ) or when we are unable to retrieve the variable name and raise_exc is set to True . function varname . will ( caller=1 , raise_exc=True ) </> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters caller (int, optional) \u2014 At which stack this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function varname . inject ( obj ) </> Inject attribute __varname__ to an object Examples >>> class MyList ( list ): >>> pass >>> a = varname . inject ( MyList ()) >>> b = varname . inject ( MyList ()) >>> a . __varname__ == 'a' >>> b . __varname__ == 'b' >>> a == b >>> # other methods not affected >>> a . append ( 1 ) >>> b . append ( 1 ) >>> a == b Parameters obj (object) \u2014 An object that can be injected Raises VarnameRetrievingError \u2014 When __varname__ is unable to be set as an attribute Returns (object) The object with varname injected function varname . nameof ( var , *more_vars , caller=1 , full=None ) </> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of caller (int, optional) \u2014 The depth of the caller (this function) is called. This is useful if you want to wrap this function. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. function varname . debug ( var , *more_vars , prefix='DEBUG: ' , merge=False , repr=True ) </> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) function varname . namedtuple ( *args , **kwargs ) </> A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple ( 'Name' , [ 'first' , 'last' ]) You can do: >>> from varname import namedtuple >>> Name = namedtuple ([ 'first' , 'last' ]) Parameters *args \u2014 arguments for collections.namedtuple except typename **kwargs \u2014 keyword arguments for collections.namedtuple except typename Returns (type) The namedtuple you desired. class varname . Wrapper ( value , raise_exc=True ) </> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps","title":"API"},{"location":"api/varname/#varname","text":"</> Dark magics about variable name in python Classes VarnameRetrievingError \u2014 When failed to retrieve the varname </> Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> inject ( obj ) (object) \u2014 Inject attribute __varname__ to an object </> namedtuple ( *args , **kwargs ) (type) \u2014 A shortcut for namedtuple </> nameof ( var , *more_vars , caller , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( caller , raise_exc ) (str, optional) \u2014 Get the variable name that assigned by function/class calls </> will ( caller , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> class","title":"varname"},{"location":"api/varname/#varnamevarnameretrievingerror","text":"</> Bases Exception BaseException When failed to retrieve the varname function","title":"varname.VarnameRetrievingError"},{"location":"api/varname/#varnamevarname","text":"</> Get the variable name that assigned by function/class calls Parameters caller (int, optional) \u2014 The call stack index, indicating where this function is called relative to where the variable is finally retrieved raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (str, optional) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variable used on the left of the assign node. (e.g: a.b = func() ) or when we are unable to retrieve the variable name and raise_exc is set to True . function","title":"varname.varname"},{"location":"api/varname/#varnamewill","text":"</> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters caller (int, optional) \u2014 At which stack this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function","title":"varname.will"},{"location":"api/varname/#varnameinject","text":"</> Inject attribute __varname__ to an object Examples >>> class MyList ( list ): >>> pass >>> a = varname . inject ( MyList ()) >>> b = varname . inject ( MyList ()) >>> a . __varname__ == 'a' >>> b . __varname__ == 'b' >>> a == b >>> # other methods not affected >>> a . append ( 1 ) >>> b . append ( 1 ) >>> a == b Parameters obj (object) \u2014 An object that can be injected Raises VarnameRetrievingError \u2014 When __varname__ is unable to be set as an attribute Returns (object) The object with varname injected function","title":"varname.inject"},{"location":"api/varname/#varnamenameof","text":"</> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of caller (int, optional) \u2014 The depth of the caller (this function) is called. This is useful if you want to wrap this function. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. function","title":"varname.nameof"},{"location":"api/varname/#varnamedebug","text":"</> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) function","title":"varname.debug"},{"location":"api/varname/#varnamenamedtuple","text":"</> A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple ( 'Name' , [ 'first' , 'last' ]) You can do: >>> from varname import namedtuple >>> Name = namedtuple ([ 'first' , 'last' ]) Parameters *args \u2014 arguments for collections.namedtuple except typename **kwargs \u2014 keyword arguments for collections.namedtuple except typename Returns (type) The namedtuple you desired. class","title":"varname.namedtuple"},{"location":"api/varname/#varnamewrapper","text":"</> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps","title":"varname.Wrapper"},{"location":"api/source/varname/","text":"SOURCE CODE varname DOCS \"\"\"Dark magics about variable name in python\"\"\" import ast import dis import sys import warnings from typing import Union , Tuple , Any , Optional from types import FrameType , CodeType from collections import namedtuple as standard_namedtuple from functools import lru_cache import executing __version__ = \"0.5.3\" __all__ = [ \"VarnameRetrievingError\" , \"varname\" , \"will\" , \"inject\" , \"nameof\" , \"namedtuple\" , \"Wrapper\" , \"debug\" ] class VarnameRetrievingError ( Exception ): DOCS \"\"\"When failed to retrieve the varname\"\"\" def varname ( caller : int = 1 , raise_exc : bool = True ) -> Optional [ str ]: DOCS \"\"\"Get the variable name that assigned by function/class calls Args: caller: The call stack index, indicating where this function is called relative to where the variable is finally retrieved raise_exc: Whether we should raise an exception if failed to retrieve the name. Returns: The variable name, or `None` when `raise_exc` is `False` and we failed to retrieve the variable name. Raises: VarnameRetrievingError: When there is invalid variable used on the left of the assign node. (e.g: `a.b = func()`) or when we are unable to retrieve the variable name and `raise_exc` is set to `True`. UserWarning: When there are multiple target in the assign node. (e.g: `a = b = func()`, in such a case, `b == 'a'`, may not be the case you want) \"\"\" node = _get_node ( caller , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the ast node.\" ) return None node = _lookfor_parent_assign ( node ) if not node : if raise_exc : raise VarnameRetrievingError ( 'Failed to retrieve the variable name.' ) return None # Need to actually check that there's just one # give warnings if: a = b = func() if len ( node . targets ) > 1 : warnings . warn ( \"Multiple targets in assignment, variable name \" \"on the very left will be used.\" , UserWarning ) target = node . targets [ 0 ] return _node_name ( target ) def will ( caller : int = 1 , raise_exc : bool = True ) -> Optional [ str ]: DOCS \"\"\"Detect the attribute name right immediately after a function call. Examples: >>> class AwesomeClass: >>> def __init__(self): >>> self.will = None >>> def permit(self): >>> self.will = will() >>> if self.will == 'do': >>> # let self handle do >>> return self >>> raise AttributeError( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do(self): >>> if self.will != 'do': >>> raise AttributeError(\"You don't have permission to do\") >>> return 'I am doing!' >>> awesome = AwesomeClass() >>> # AttributeError: You don't have permission to do >>> awesome.do() >>> # AttributeError: Should do something with AwesomeClass object >>> awesome.permit() >>> awesome.permit().do() == 'I am doing!' Args: caller: At which stack this function is called. raise_exc: Raise exception we failed to detect Returns: The attribute name right after the function call If there is no attribute attached and `raise_exc` is `False` Raises: VarnameRetrievingError: When `raise_exc` is `True` and we failed to detect the attribute name (including not having one) \"\"\" node = _get_node ( caller , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the frame.\" ) return None # try to get node inst.attr from inst.attr() node = node . parent # see test_will_fail if not isinstance ( node , ast . Attribute ): if raise_exc : raise VarnameRetrievingError ( \"Function `will` has to be called within \" \"a method/property of a class.\" ) return None # ast.Attribute return node . attr def inject ( obj : object ) -> object : DOCS \"\"\"Inject attribute `__varname__` to an object Examples: >>> class MyList(list): >>> pass >>> a = varname.inject(MyList()) >>> b = varname.inject(MyList()) >>> a.__varname__ == 'a' >>> b.__varname__ == 'b' >>> a == b >>> # other methods not affected >>> a.append(1) >>> b.append(1) >>> a == b Args: obj: An object that can be injected Raises: VarnameRetrievingError: When `__varname__` is unable to be set as an attribute Returns: The object with __varname__ injected \"\"\" vname = varname () try : setattr ( obj , '__varname__' , vname ) except AttributeError : raise VarnameRetrievingError ( 'Unable to inject __varname__.' ) from None return obj def nameof ( var , * more_vars , # pylint: disable=unused-argument DOCS caller : int = 1 , full : Optional [ bool ] = None ) -> Union [ str , Tuple [ str ]]: \"\"\"Get the names of the variables passed in Examples: >>> a = 1 >>> nameof(a) # 'a' >>> b = 2 >>> nameof(a, b) # ('a', 'b') >>> x = lambda: None >>> x.y = 1 >>> nameof(x.y, full=True) # 'x.y' Note: This function works with the environments where source code is available, in other words, the callee's node can be retrieved by `executing`. In some cases, for example, running code from python shell/REPL or from `exec`/`eval`, we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Args: var: The variable to retrieve the name of *more_vars: Other variables to retrieve the names of caller: The depth of the caller (this function) is called. This is useful if you want to wrap this function. full: Whether report the full path of the variable. For example: `nameof(a.b.c, full=True)` give you `a.b.c` instead of `c` Returns: The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises: VarnameRetrievingError: When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. \"\"\" node = _get_node ( caller - 1 , raise_exc = True ) if not node : # We can't retrieve the node by executing. # It can be due to running code from python/shell, exec/eval or # other environments where sourcecode cannot be reached # make sure we keep it simple (only single variable passed and no # full passed) to use _bytecode_nameof if not more_vars and full is None : return _bytecode_nameof ( caller + 1 ) # We are anyway raising exceptions, no worries about additional burden # of frame retrieval again # may raise exception, just leave it as is frame = _get_frame ( caller ) source = frame . f_code . co_filename if source == '<stdin>' : raise VarnameRetrievingError ( \"Are you trying to call nameof in REPL/python shell? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) if source == '<string>' : raise VarnameRetrievingError ( \"Are you trying to call nameof from exec/eval? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) raise VarnameRetrievingError ( \"Source code unavailable, nameof can only retrieve the name of \" \"a single variable, and argument `full` should not be specified.\" ) ret = [] for arg in node . args : if not full or isinstance ( arg , ast . Name ): ret . append ( _node_name ( arg )) else : # traverse the node to get the full name: nameof(a.b.c) # arg: # Attribute(value=Attribute(value=Name(id='a', ctx=Load()), # attr='b', # ctx=Load()), # attr='c', # ctx=Load()) full_name = [] while not isinstance ( arg , ast . Name ): if not isinstance ( arg , ast . Attribute ): raise VarnameRetrievingError ( 'Can only retrieve full names of ' '(chained) attribute calls by nameof.' ) full_name . append ( arg . attr ) arg = arg . value # now it is an ast.Name full_name . append ( arg . id ) ret . append ( '.' . join ( reversed ( full_name ))) return ret [ 0 ] if not more_vars else tuple ( ret ) def debug ( var , * more_vars , DOCS prefix : str = 'DEBUG: ' , merge : bool = False , repr : bool = True ) -> None : # pylint: disable=redefined-builtin \"\"\"Print variable names and values. Examples: >>> a = 1 >>> b = object >>> print(f'a={a}') # previously, we have to do >>> print(f'{a=}') # or with python3.8 >>> # instead we can do: >>> debug(a) # DEBUG: a=1 >>> debug(a, prefix='') # a=1 >>> debug(a, b, merge=True) # a=1, b=<object object at 0x2b9a4c89cf00> Args: var: The variable to print *more_vars: Other variables to print prefix: A prefix to print for each line merge: Whether merge all variables in one line or not repr: Print the value as `repr(var)`? otherwise `str(var)` \"\"\" var_names = nameof ( var , * more_vars , caller = 2 , full = True ) if not isinstance ( var_names , tuple ): var_names = ( var_names , ) variables = ( var , * more_vars ) name_and_values = [ f \" { var_name } = { variables [ i ] !r} \" if repr else f \" { var_name } = { variables [ i ] } \" for i , var_name in enumerate ( var_names )] if merge : print ( f \" { prefix }{ ', ' . join ( name_and_values ) } \" ) else : for name_and_value in name_and_values : print ( f \" { prefix }{ name_and_value } \" ) def namedtuple ( * args , ** kwargs ) -> type : DOCS \"\"\"A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple('Name', ['first', 'last']) You can do: >>> from varname import namedtuple >>> Name = namedtuple(['first', 'last']) Args: *args: arguments for `collections.namedtuple` except `typename` **kwargs: keyword arguments for `collections.namedtuple` except `typename` Returns: The namedtuple you desired. \"\"\" warnings . warn ( \"Shortcut for namedtuple is deprecated and \" \"will be removed in 0.6.0. Use the standard way instead.\" , DeprecationWarning ) typename = varname ( raise_exc = True ) return standard_namedtuple ( typename , * args , ** kwargs ) class Wrapper : DOCS \"\"\"A wrapper with ability to retrieve the variable name Examples: >>> foo = Wrapper(True) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper(val) >>> # bar.name == 'bar' >>> # bar.value is val Args: value: The value to be wrapped raise_exc: Whether to raise exception when varname is failed to retrieve Attributes: name: The variable name to which the instance is assigned value: The value this wrapper wraps \"\"\" def __init__ ( self , value : Any , raise_exc : bool = True ): self . name = varname ( raise_exc = raise_exc ) self . value = value def __str__ ( self ) -> str : return repr ( self . value ) def __repr__ ( self ) -> str : return ( f \"< { self . __class__ . __name__ } \" f \"(name= { self . name !r} , value= { self . value !r} )>\" ) def _get_frame ( caller : int ) -> FrameType : \"\"\"Get the frame at `caller` depth\"\"\" try : return sys . _getframe ( caller + 1 ) except Exception as exc : raise VarnameRetrievingError from exc def _get_node ( caller : int , raise_exc : bool = True ) -> Optional [ ast . AST ]: \"\"\"Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge `reticulate`, where only first frame is kept. When the node can not be retrieved, try to return the first statement. \"\"\" try : frame = _get_frame ( caller + 2 ) except VarnameRetrievingError : return None exet = executing . Source . executing ( frame ) if exet . node : return exet . node if exet . source . text and exet . source . tree and raise_exc : raise VarnameRetrievingError ( \"Couldn't retrieve the call node. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return None def _lookfor_parent_assign ( node : ast . AST ) -> Optional [ ast . Assign ]: \"\"\"Look for an ast.Assign node in the parents\"\"\" while hasattr ( node , 'parent' ): node = node . parent if isinstance ( node , ast . Assign ): return node return None def _node_name ( node : ast . AST ) -> str : \"\"\"Get the node node name. Raises VarnameRetrievingError when failed \"\"\" if isinstance ( node , ast . Name ): return node . id if isinstance ( node , ast . Attribute ): return node . attr raise VarnameRetrievingError ( f \"Can only get name of a variable or attribute, \" f \"not { ast . dump ( node ) } \" ) def _bytecode_nameof ( caller : int = 1 ) -> str : \"\"\"Bytecode version of nameof as a fallback\"\"\" frame = _get_frame ( caller ) return _bytecode_nameof_cached ( frame . f_code , frame . f_lasti ) @lru_cache () def _bytecode_nameof_cached ( code : CodeType , offset : int ) -> str : \"\"\"Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with `eval`, or other circumstances where the code is manipulated to run but sourcecode is not available. \"\"\" instructions = list ( dis . get_instructions ( code )) ( current_instruction_index , current_instruction ), = ( ( index , instruction ) for index , instruction in enumerate ( instructions ) if instruction . offset == offset ) if current_instruction . opname not in ( \"CALL_FUNCTION\" , \"CALL_METHOD\" ): raise VarnameRetrievingError ( \"Did you call nameof in a weird way?\" ) name_instruction = instructions [ current_instruction_index - 1 ] if not name_instruction . opname . startswith ( \"LOAD_\" ): raise VarnameRetrievingError ( \"Argument must be a variable or attribute\" ) name = name_instruction . argrepr if not name . isidentifier (): raise VarnameRetrievingError ( f \"Found the variable name { name !r} which is obviously wrong. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return name","title":"varname"}]}